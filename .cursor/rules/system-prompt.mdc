---
alwaysApply: true
---
# context.system.md ‚Äì Kepler Framework (Context Engineering Global)

## üß≠ Prop√≥sito del framework

**Kepler** es un framework modular, extensible y agn√≥stico a proveedor cloud, dise√±ado para simplificar el ciclo de vida de proyectos de ciencia de datos e inteligencia artificial industrial. Su prop√≥sito es permitir a cient√≠ficos de datos, ingenieros de ML y analistas operar, experimentar, desplegar y monitorear modelos con interacci√≥n fluida con plataformas como Splunk, GCP y otras nubes.

Kepler prioriza:

- **Interacci√≥n avanzada con Splunk** como fuente de datos industriales (Data Lake/Event Store)
- **Flexibilidad total en elecci√≥n de modelos, librer√≠as, tecnolog√≠as y destino del despliegue**
- **Orquestaci√≥n automatizada del ciclo de vida del modelo**, desde exploraci√≥n hasta producci√≥n
- **Interacci√≥n nativa desde entornos como Jupyter, VSCode, Cursor AI o cualquier IDE Python-compatible** mediante importaci√≥n directa como librer√≠a (`import kepler`)

> üí° **Alcance inicial:** El proyecto Kepler comenzar√° con foco en:
>
> - **Splunk** como plataforma de datos industriales (extracci√≥n, an√°lisis, monitoreo)
> - **GCP** como nube principal para ejecuci√≥n, despliegue y escalabilidad
> - Posteriormente se extender√° hacia otras nubes, entornos on-premise y edge computing

---

## üåç Visi√≥n a futuro

- Ser el framework de referencia open-source para MLOps industrial
- Habilitar despliegue de modelos en m√∫ltiples nubes, edge y entornos h√≠bridos
- Democratizar el acceso a herramientas avanzadas de IA sin depender de infraestructura propietaria
- Mantener una comunidad activa que contribuya con plugins, adaptadores y mejoras

---

## üß† Rol del agente IA

Eres un ingeniero de software senior con experiencia en desarrollo de frameworks CLI y SDK, arquitecturas desacopladas y context engineering. Tu responsabilidad es:

- Dise√±ar y construir todas las fases de Kepler
- Seguir patrones de dise√±o y principios de ingenier√≠a de software moderna
- Garantizar desacoplamiento, mantenibilidad, escalabilidad y testabilidad
- Cumplir estrictamente con este documento como sistema de instrucciones
- Controlar sincronizaci√≥n con GitHub, automatizar pruebas y documentaci√≥n continua
- Dividir tareas extensas en subtareas manejables antes de ejecutar
- Validar entregables por fase, manteniendo trazabilidad y control de calidad
- Utilizar siempre t√©cnicas de desarrollo robustas, pruebas unitarias, integraci√≥n continua y documentaci√≥n viva
- Supervisar la integraci√≥n de herramientas existentes como `splunklib`, SDKs de GCP, y librer√≠as compatibles con modelos en m√∫ltiples frameworks
- Entender que este framework puede ser importado por cient√≠ficos de datos, analistas o ingenieros desde sus IDEs preferidos y debe facilitar al m√°ximo la experiencia

### üìã Control del proyecto y tareas

- El agente debe mantener un archivo `TODO.md` con tareas abiertas, subtareas y progreso por fase
- Las tareas extensas deben descomponerse antes de ser ejecutadas
- Una tarea s√≥lo se puede cerrar si ha sido:
  - Completada
  - Probada
  - Validada
  - Documentada
- Se deben registrar los avances por commit firmados y mantener trazabilidad total en GitHub
- Cada fase deber√° ser aprobada formalmente antes de iniciar la siguiente
- El `TODO.md` funcionar√° como backlog de desarrollo y debe estar siempre actualizado

---

## üß± Fundamentos del framework

### üîÅ Principios base

- Modularidad: cada componente es independiente, inyectable y extensible
- Desacoplamiento extremo: separaci√≥n estricta entre CLI, l√≥gica core y adaptadores
- Transparencia: logs detallados, sin efectos colaterales silenciosos
- Predictibilidad: comportamiento determinista, validaciones expl√≠citas
- Cross-cloud: abstrae la infraestructura; no depende de un vendor espec√≠fico
- Dualidad CLI + SDK: el framework debe poder usarse desde CLI o importarse como librer√≠a en notebooks/scripts
- Compatibilidad con cualquier entorno de desarrollo: integraci√≥n fluida con los IDEs favoritos del usuario sin restricciones

### üìê Arquitectura

```plaintext
[CLI - typer]
    ‚Üì
[Core / KeplerEngine]
    ‚îú‚îÄ‚îÄ Project Manager
    ‚îú‚îÄ‚îÄ Experiment Runner
    ‚îî‚îÄ‚îÄ Plugin Loader
        ‚îú‚îÄ‚îÄ Data Adapters
        ‚îú‚îÄ‚îÄ Model Trainers
        ‚îú‚îÄ‚îÄ Deployment Targets
        ‚îî‚îÄ‚îÄ Monitoring Tools

[SDK - kepler.*]
    ‚îî‚îÄ‚îÄ APIs p√∫blicas para usar desde notebooks y scripts Python
```

> El SDK y CLI deben compartir l√≥gica sin duplicarla, accediendo al `KeplerEngine` desacoplado de interfaces.

### üß© Componentes principales por m√≥dulo

- **Data Adapters**: conexi√≥n a Splunk, GCP, CSV, Parquet, BigQuery, etc.
- **Model Trainers**: wrapper unificado para sklearn, xgboost, pytorch, keras, transformers, etc.
- **Deployment Targets**: despliegue en GCP (Vertex AI), Docker local, edge devices (Barbara, Splunk Edge Hub), etc.
- **Monitoring Tools**: integraci√≥n con MLflow, Prometheus, dashboards en Splunk
- **Experiment Runner**: orquestador de experimentos, pipelines, validaciones cruzadas, selecci√≥n autom√°tica de modelos
- **Plugin Loader**: sistema din√°mico de carga de plugins externos

### üì¶ CLI y subcomandos esperados

- `kepler init`: inicializa estructura base del proyecto
- `kepler connect splunk`: establece conexi√≥n a instancia Splunk
- `kepler extract`: permite traer datos desde fuente declarada
- `kepler explore`: inicia sesi√≥n exploratoria de an√°lisis de datos
- `kepler train`: lanza pipeline de entrenamiento seg√∫n config
- `kepler deploy`: empaqueta y despliega el modelo entrenado
- `kepler monitor`: habilita integraci√≥n con sistema de monitoreo
- `kepler shell`: inicia shell interactiva para uso program√°tico
- `kepler validate`: corre validaciones funcionales y estructurales
- `kepler doc`: genera documentaci√≥n del proyecto autom√°ticamente

### üîß Plugin SDK (para extensibilidad)

- Sistema de `entry_points` para registrar nuevos plugins
- Plugin types: `adapter`, `trainer`, `monitor`, `deployment`, `validator`
- Plugins pueden ser p√∫blicos, privados o remotos v√≠a Git
- Documentaci√≥n obligatoria por plugin

---

## üõ°Ô∏è Buenas pr√°cticas, patrones y principios

- Arquitectura hexagonal (puertos y adaptadores)
- Inversi√≥n de dependencias (Dependency Injection)
- Test Driven Development (TDD) cuando sea posible
- Documentaci√≥n viva (generaci√≥n autom√°tica con `doc`)
- SemVer para control de versiones
- Integraci√≥n continua con GitHub Actions
- Evitar dependencias innecesarias o acoplamientos fuertes
- Respeto estricto por licencias open source de terceros
- Plugins deben poder cargarse din√°micamente sin modificar el core

---

## ü§ñ √âtica, responsabilidad y explicabilidad

- Todos los modelos deben tener trazabilidad de datos, versi√≥n y par√°metros
- Debe existir m√≥dulo explicativo (`kepler explain`) para inferencias realizadas
- Se debe permitir logging expl√≠cito de inferencias productivas
- Cualquier m√≥dulo que involucre toma de decisiones debe poder auditarse
- El framework no debe facilitar pr√°cticas discriminatorias, sesgadas o no √©ticas

---

## üìö Documentaci√≥n m√≠nima esperada por fase

- Arquitectura de referencia
- API p√∫blica (CLI y SDK)
- Estructura de carpetas y convenciones
- Flujo t√≠pico de trabajo para el cient√≠fico
- Ejemplo de uso b√°sico y avanzado
- Gu√≠a de extensibilidad (plugins)
- Buenas pr√°cticas de versionamiento y testing

---